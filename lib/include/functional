// vim: set ft=cpp:
#ifndef __NOSTDLIB_FUCNTIONAL_H__
#define __NOSTDLIB_FUCNTIONAL_H__

#include <memory>
#include <type_traits>

namespace std
{
    template <typename T>
    class reference_wrapper;

    template <typename T>
    struct plus
    {
        auto operator()(const T& a, const T& b) { return a + b; }
    };
    template <typename T>
    struct minus
    {
        auto operator()(const T& a, const T& b) { return a - b; }
    };
    template <typename T>
    struct multiplies
    {
        auto operator()(const T& a, const T& b) { return a * b; }
    };
    template <typename T>
    struct divides
    {
        auto operator()(const T& a, const T& b) { return a / b; }
    };
    template <typename T>
    struct modulus
    {
        auto operator()(const T& a, const T& b) { return a % b; }
    };

    template <typename T>
    struct equal_to
    {
        auto operator()(const T& a, const T& b) { return a == b; }
    };
    template <typename T>
    struct not_equal_to
    {
        auto operator()(const T& a, const T& b) { return a != b; }
    };
    template <typename T>
    struct greater
    {
        auto operator()(const T& a, const T& b) { return a > b; }
    };
    template <typename T>
    struct less
    {
        auto operator()(const T& a, const T& b) { return a < b; }
    };
    template <typename T>
    struct greater_equal
    {
        auto operator()(const T& a, const T& b) { return a >= b; }
    };
    template <typename T>
    struct less_equal
    {
        auto operator()(const T& a, const T& b) { return a <= b; }
    };

    template <typename T>
    struct logical_and
    {
        auto operator()(const T& a, const T& b) { return a && b; }
    };
    template <typename T>
    struct logical_or
    {
        auto operator()(const T& a, const T& b) { return a || b; }
    };
    template <typename T>
    struct bit_and
    {
        auto operator()(const T& a, const T& b) { return a & b; }
    };
    template <typename T>
    struct bit_or
    {
        auto operator()(const T& a, const T& b) { return a | b; }
    };
    template <typename T>
    struct bit_xor
    {
        auto operator()(const T& a, const T& b) { return a ^ b; }
    };

    template <typename T>
    struct negate
    {
        auto operator()(const T& a) { return -a; }
    };
    template <typename T>
    struct logical_not
    {
        auto operator()(const T& a) { return !a; }
    };
    template <typename T>
    struct bit_not
    {
        auto operator()(const T& a) { return ~a; }
    };

    template <typename T>
    class hash;

    template <>
    class hash<uint64_t>
    {
    public:
        auto operator()(uint64_t v) const -> uint32_t
        {
            static_assert(sizeof(uint32_t) == 4, "Expected sizeof(int) == 4");
            return (uint32_t)(v ^ (v >> 32));
        }
    };

    template <>
    class hash<int64_t>
    {
    public:
        auto operator()(int64_t v) const -> uint32_t
        {
            static_assert(sizeof(uint32_t) == 4, "Expected sizeof(int) == 4");
            return (uint32_t)(v ^ (v >> 32));
        }
    };

    template <>
    class hash<int>
    {
    public:
        auto operator()(int v) const -> uint32_t { return v; }
    };

    template <>
    class hash<uint32_t>
    {
    public:
        auto operator()(int v) const -> uint32_t { return v; }
    };

    template <typename T>
    class hash<T*>
    {
    public:
        auto operator()(T* p) const -> uint32_t { return reinterpret_cast<uintptr_t>(p); }
    };

    class CStringHash
    {
    public:
        auto operator()(const char* str) const -> uint32_t
        {
            uint32_t value = 0;
            while (*str != 0)
            {
                value = (value << 8) | (value >> 24);
                value += *str++;
            }
            return value;
        }
    };

} // namespace frg



#endif
